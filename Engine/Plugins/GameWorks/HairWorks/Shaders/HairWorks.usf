#include "GeneratedUniformBuffers.usf" 
#include "ShaderVersion.usf"
#include "Common.usf"
#include "ReflectionEnvironmentShared.usf"
#include "BRDF.usf"
#include "SHCommon.usf"
#include "VelocityCommon.usf"

#define WRITES_VELOCITY_TO_GBUFFER		(OUTPUT_GBUFFER_VELOCITY && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED))


#include "DeferredShadingCommon.usf"		// FGBufferData
struct FVertexFactoryInterpolantsVSToPS
{};
#include "ShadowDepthCommon.usf"

#define GFSDK_HAIR_DECLARE_VELOCITY_ATTR



#include "GFSDK_HairWorks_ShaderCommon.usf"

GFSDK_Hair_ConstantBuffer HairConstantBuffer;

SamplerState TextureSampler;

Texture2D RootColorTexture;
Texture2D TipColorTexture;
Texture2D SpecularColorTexture;

GFSDK_HAIR_DECLARE_SHADER_RESOURCES(t10, t11, t12, t13, t14);
 
float3 getBarycentricCenter(GFSDK_HAIR_POSITION_BUFFER_TYPE buff, float2 coords, int3 vertIndices)
{
	float3 v0 = buff.Load( vertIndices[0] ).xyz;
	float3 v1 = buff.Load( vertIndices[1] ).xyz;
	float3 v2 = buff.Load( vertIndices[2] ).xyz;
	
	return coords.x * v0 + coords.y * v1 + (1.0f - coords.x - coords.y) * v2;
}
 
float3 getLerpedWorldPosForHair(GFSDK_HAIR_POSITION_BUFFER_TYPE buff, float hairFrac, float2 coords, int3 vertIndices0, int3 vertIndices1)
{
	float3 p0 = getBarycentricCenter(buff, coords, vertIndices0);
	float3 p1 = getBarycentricCenter(buff, coords, vertIndices1);
	
	return lerp(p0, p1, hairFrac);
}

void Main(
	GFSDK_Hair_PixelShaderInput input
	,out float4 OutColor		: SV_Target0
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED) && !NO_GBUFFER
	,out float4 OutGBufferA : SV_Target1 
	,out float4 OutGBufferB : SV_Target2
	,out float4 OutGBufferC : SV_Target3
	,out float4 OutGBufferD : SV_Target4
	#if ALLOW_STATIC_LIGHTING
		,out float4 OutGBufferE : SV_Target5
		#if WRITES_VELOCITY_TO_GBUFFER
			, out float4 OutGBufferVelocity : SV_Target6
		#endif
	#else
		#if WRITES_VELOCITY_TO_GBUFFER
			, out float4 OutGBufferVelocity : SV_Target5
		#endif
	#endif
#endif

)
{
	// Shader attributes
	GFSDK_Hair_ShaderAttributes shaderAttributes = GFSDK_Hair_GetShaderAttributes(input, HairConstantBuffer);

	// JDM: What is this doing every pixel? Why is it writing to a "constant buffer"?
	// Setup material
	if (HairConstantBuffer.useSpecularTexture)
		HairConstantBuffer.defaultMaterial.specularColor.rgb = SpecularColorTexture.SampleLevel(TextureSampler, shaderAttributes.texcoords.xy, 0).rgb;

	// Sum
	float3 hairColor = GFSDK_Hair_SampleHairColorTex(
		HairConstantBuffer, 
		HairConstantBuffer.defaultMaterial, 
		TextureSampler,
		RootColorTexture,
		TipColorTexture,
		shaderAttributes.texcoords
		);

	#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED) && !NO_GBUFFER

		FGBufferData GBuffer = (FGBufferData)0;

		GBuffer.ShadingModelID = SHADINGMODELID_GFSDK_HAIR;

		// Metallic, Specular and Roughness are stored in a RGBA8_UNORM GBuffer texture
		// TODO: implement a non-linear quantization of specularPrimaryPower
		GBuffer.Metallic = HairConstantBuffer.defaultMaterial.diffuseBlend;
		GBuffer.Specular = HairConstantBuffer.defaultMaterial.specularPrimaryScale;
		GBuffer.Roughness = HairConstantBuffer.defaultMaterial.specularPrimaryPower / GFSDK_HAIR_MAX_SPECULAR_POWER;

		// hair tangent (this is the vector along the path of the hair ie – a tangent to the hair ‘normal’ – which there are an infinite amount of cos it’s a strand)
		GBuffer.WorldNormal = shaderAttributes.T;

		// surface normal (this is the normal of the surface of the hair at the scalp)
		GBuffer.CustomData = EncodeNormal( shaderAttributes.N );

		// RGBA8_UNORM_SRGB texture
		GBuffer.BaseColor = hairColor;

		// RGBA8_UNORM texture
		GBuffer.PrecomputedShadowFactors.rgb = HairConstantBuffer.defaultMaterial.specularColor;

		#if !ALLOW_STATIC_LIGHTING
			float4 OutGBufferE = 0;
		#endif

		#if WRITES_VELOCITY_TO_GBUFFER
			{
				float		hairtex		= shaderAttributes.texcoords.z; 
				const int	numPoints	= HairConstantBuffer.strandPointCount;
				float		hairCoord	= hairtex * float(numPoints-1); 
				int			vertexID0	= floor(hairCoord); 
				int			vertexID1	= min(vertexID0 + 1, numPoints-1); 
				float		hairFrac	= frac(hairCoord); 
		
				int3 hairIndices = floor(GFSDK_HAIR_RESOURCE_FACE_HAIR_INDICES.Load(input.primitiveID));
				int3 rootIndices =  hairIndices * numPoints;
		
				int3	vertexIndices0 = rootIndices + int3(vertexID0, vertexID0, vertexID0);
				int3	vertexIndices1 = rootIndices + int3(vertexID1, vertexID1, vertexID1);
		
				float2	coords = GFSDK_Hair_UnpackFloat2(input.coords);

				//float hairFrac, float2 coords, int3 vertIndices0, int3 vertIndices1)
				float3 wp0 = getLerpedWorldPosForHair(GFSDK_HAIR_RESOURCE_MASTER_PREV_POSITIONS, hairFrac, coords, vertexIndices0, vertexIndices1);
				float3 wp1 = getLerpedWorldPosForHair(GFSDK_HAIR_RESOURCE_MASTER_POSITIONS, hairFrac, coords, vertexIndices0, vertexIndices1);
				
				float sp0 = mul(float4(wp0.xyz, 1), View.PrevTranslatedWorldToClip);
				float sp1 = mul(float4(wp1.xyz, 1), View.TranslatedWorldToClip);
			
				// Velocity
				float2 Velocity = Calculate2DVelocity(sp0, sp1);

				// Make sure not to touch 0,0 which is clear color
//				GBuffer.Velocity = float4(EncodeVelocityToTexture(Velocity), 0, 0);// * BasePassInterpolants.VelocityPrevScreenPosition.z;
				GBuffer.Velocity = float4(0.5, 0.5, 0, 0);// * BasePassInterpolants.VelocityPrevScreenPosition.z;
			}
		#else
			GBuffer.Velocity = 0;
			float4 OutGBufferVelocity = 0;
		#endif

		float QuantizationBias = 1.0; //PseudoRandom( MaterialParameters.SVPosition.xy ) * 0.5 - 0.5;
		EncodeGBuffer(GBuffer, OutGBufferA, OutGBufferB, OutGBufferC, OutGBufferD, OutGBufferE, OutGBufferVelocity, QuantizationBias);
	#endif 

	// Not return, all output params
}

float ShadowDepthMain(in float4 Position : SV_Position) : SV_Depth
{
	//return 1;
	return Position.z * Position.w * ShadowParams.y + ShadowParams.x;
}

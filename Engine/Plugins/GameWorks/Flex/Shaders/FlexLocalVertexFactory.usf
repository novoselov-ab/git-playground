// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved..

/*=============================================================================
	FlexLocalVertexFactory.usf: Local vertex factory shader code. 

	This is a copy of LocalVertexFactory.usf modified to be used by Flex
=============================================================================*/

#include "VertexFactoryCommon.usf"
#include "LocalVertexFactoryCommon.usf"

float4x4 PreviousLocalToWorld;
float4 LightMapCoordinateScaleBias;
float4 ShadowMapCoordinateScaleBias;


#ifndef USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL
	#error "USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL should have been defined"
#endif
#define USE_DITHERED_LOD_TRANSITION USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL

#ifndef USE_INSTANCING_EMULATED
	#define USE_INSTANCING_EMULATED (0)
#endif


Buffer<float4> ClusterTranslations;
Buffer<float4> ClusterRotations;

// rotate vector by quaternion (q, w)
float3 QuatRotate(float4 Quat, float3 Pos)
{
	return Pos*(2.0*Quat.w*Quat.w - 1.0) + cross(Quat.xyz, Pos)*Quat.w*2.0 + Quat.xyz*dot(Quat.xyz, Pos)*2.0;
}

float3 SkinPositionSingle(float3 LocalPos, float ClusterWeight, int ClusterIndex)
{
	if (ClusterIndex > -1)
	{
		return (QuatRotate(ClusterRotations[ClusterIndex], LocalPos.xyz) + ClusterTranslations[ClusterIndex].xyz)*ClusterWeight;
	}
	else
	{
		return float3(0.0, 0.0, 0.0);
	}
}

float3 SkinPosition(float3 LocalPos, float4 ClusterWeights, int4 ClusterIndices)
{
	float3 Pos = float3(0.0, 0.0, 0.0);

		Pos += SkinPositionSingle(LocalPos.xyz, ClusterWeights.x, ClusterIndices.x);
	Pos += SkinPositionSingle(LocalPos.xyz, ClusterWeights.y, ClusterIndices.y);
	Pos += SkinPositionSingle(LocalPos.xyz, ClusterWeights.z, ClusterIndices.z);
	Pos += SkinPositionSingle(LocalPos.xyz, ClusterWeights.w, ClusterIndices.w);

	return Pos;
}

half3 SkinNormalSingle(half3 LocalNormal, float ClusterWeight, int ClusterIndex)
{
	if (ClusterIndex > -1)
	{
		return QuatRotate(ClusterRotations[ClusterIndex], LocalNormal.xyz)*ClusterWeight;
	}
	else
	{
		return half3(0.0, 0.0, 0.0);
	}
}

half3 SkinNormal(float3 LocalNormal, float4 ClusterWeights, int4 ClusterIndices)
{
	half3 Normal = half3(0.0, 0.0, 0.0);

		Normal += SkinNormalSingle(LocalNormal.xyz, ClusterWeights.x, ClusterIndices.x);
	Normal += SkinNormalSingle(LocalNormal.xyz, ClusterWeights.y, ClusterIndices.y);
	Normal += SkinNormalSingle(LocalNormal.xyz, ClusterWeights.z, ClusterIndices.z);
	Normal += SkinNormalSingle(LocalNormal.xyz, ClusterWeights.w, ClusterIndices.w);

	return Normal;
}

struct FVertexFactoryInput
{
	float4	Position	: ATTRIBUTE0;
#if METAL_PROFILE
	//@todo-rco: FIXME!
	float3	TangentX	: ATTRIBUTE1;
	float4	TangentZ	: ATTRIBUTE2;
	float4	Color		: ATTRIBUTE3;
#else
	half3	TangentX	: ATTRIBUTE1;
	// TangentZ.w contains sign of tangent basis determinant
	half4	TangentZ	: ATTRIBUTE2;
	half4	Color		: ATTRIBUTE3;
#endif	// METAL_PROFILE

#if NUM_MATERIAL_TEXCOORDS_VERTEX

	#if NUM_MATERIAL_TEXCOORDS_VERTEX > 1
		float4	PackedTexCoords4[NUM_MATERIAL_TEXCOORDS_VERTEX/2] : ATTRIBUTE4;
	#endif
	#if NUM_MATERIAL_TEXCOORDS_VERTEX == 1
		float2	PackedTexCoords2 : ATTRIBUTE4;
	#elif NUM_MATERIAL_TEXCOORDS_VERTEX == 3
		float2	PackedTexCoords2 : ATTRIBUTE5;
	#elif NUM_MATERIAL_TEXCOORDS_VERTEX == 5
		float2	PackedTexCoords2 : ATTRIBUTE6;
	#elif NUM_MATERIAL_TEXCOORDS_VERTEX == 7
		float2	PackedTexCoords2 : ATTRIBUTE7;
	#endif

#elif USE_PARTICLE_SUBUVS
	float2	TexCoords[1] : ATTRIBUTE4;
#endif

	uint4	ClusterIndices	: ATTRIBUTE8;
	float4	ClusterWeights : ATTRIBUTE9;

#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate : ATTRIBUTE15;
#endif
};

struct FPositionOnlyVertexFactoryInput
{
	float4	Position	: ATTRIBUTE0;

	uint4	ClusterIndices	: ATTRIBUTE8;
	float4	ClusterWeights : ATTRIBUTE9;

};

struct FVertexFactoryIntermediates
{
	half3x3 TangentToLocal;
	half3x3 TangentToWorld;
	half TangentToWorldSign;

	half4 Color;
};

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 PixelPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_MATERIAL_TEXCOORDS
	UNROLL
	for( int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++ )
	{
		Result.TexCoords[CoordinateIndex] = GetUV(Interpolants, CoordinateIndex);
	}
#endif	// NUM_MATERIAL_TEXCOORDS

#if USE_PARTICLE_SUBUVS
	// Output TexCoord0 for when previewing materials that use ParticleSubUV.
	Result.Particle.SubUVCoords[0] = GetUV(Interpolants, 0);
	Result.Particle.SubUVCoords[1] = GetUV(Interpolants, 0);
#endif	// USE_PARTICLE_SUBUVS

	half3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	half4 TangentToWorld2 = GetTangentToWorld2(Interpolants);
	Result.UnMirrored = TangentToWorld2.w;

	Result.VertexColor = GetColor(Interpolants);

	// Required for previewing materials that use ParticleColor
	Result.Particle.Color = half4(1,1,1,1);

	Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );

#if LIGHTMAP_UV_ACCESS
#if NEEDS_LIGHTMAP_COORDINATE
	#if (ES2_PROFILE || ES3_1_PROFILE)
		// Not supported in pixel shader
		Result.LightmapUVs = float2(0, 0);
	#else
		Result.LightmapUVs = Interpolants.LightMapCoordinate.xy;
	#endif	// ES2_PROFILE
#endif	// NEEDS_LIGHTMAP_COORDINATE
#endif	// LIGHTMAP_UV_ACCESS

	Result.TwoSidedSign = 1;
	return Result;
}

half3x3 CalcTangentToWorldNoScale(in half3x3 TangentToLocal)
{
	half3x3 LocalToWorld = GetLocalToWorld3x3();
	half3 InvScale = Primitive.InvNonUniformScale.xyz;
	LocalToWorld[0] *= InvScale.x;
	LocalToWorld[1] *= InvScale.y;
	LocalToWorld[2] *= InvScale.z;
	return mul(TangentToLocal, LocalToWorld); 
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
	Result.WorldPosition = WorldPosition;
	Result.VertexColor = Intermediates.Color;

	// does not handle instancing!
	Result.TangentToWorld = Intermediates.TangentToWorld;

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	#if NUM_MATERIAL_TEXCOORDS_VERTEX > 1
		UNROLL
		for(int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX-1; CoordinateIndex+=2)
		{
			Result.TexCoords[CoordinateIndex] = Input.PackedTexCoords4[CoordinateIndex/2].xy;
			if( CoordinateIndex+1 < NUM_MATERIAL_TEXCOORDS_VERTEX )
			{
				Result.TexCoords[CoordinateIndex+1] = Input.PackedTexCoords4[CoordinateIndex/2].zw;
			}
		}
	#endif	// NUM_MATERIAL_TEXCOORDS_VERTEX > 1
	#if NUM_MATERIAL_TEXCOORDS_VERTEX % 2 == 1
		Result.TexCoords[NUM_MATERIAL_TEXCOORDS_VERTEX-1] = Input.PackedTexCoords2;
	#endif	// NUM_MATERIAL_TEXCOORDS_VERTEX % 2 == 1
#endif	// NUM_MATERIAL_TEXCOORDS_VERTEX
	return Result;
}

float4 CalcWorldPosition(float4 Position, float4 ClusterWeights, uint4 ClusterIndices)
{
	// deformed pos
	float3 SkinnedPos = SkinPosition(Position.xyz, ClusterWeights, ClusterIndices);
		return TransformLocalToTranslatedWorld(SkinnedPos.xyz);
}

half3x3 CalcTangentToLocal(FVertexFactoryInput Input)
{
	half3x3 Result;
	half4 TangentZ = TangentBias(Input.TangentZ);

	TangentZ.xyz = SkinNormal(TangentZ.xyz, Input.ClusterWeights, Input.ClusterIndices);
	half3 TangentX = SkinNormal(TangentBias(Input.TangentX).xyz, Input.ClusterWeights, Input.ClusterIndices);

	// derive the binormal by getting the cross product of the normal and tangent
	half3 TangentY = cross(TangentZ.xyz, TangentX) * TangentZ.w;
	// Recalculate TangentX off of the other two vectors
	// This corrects quantization error since TangentX was passed in as a quantized vertex input
	// The error shows up most in specular off of a mesh with a smoothed UV seam (normal is smooth, but tangents vary across the seam)
	Result[0] = cross(TangentY, TangentZ.xyz) * TangentZ.w;
	Result[1] = TangentY;
	Result[2] = TangentZ.xyz;

	return Result;
}

half3x3 CalcTangentToWorld(FVertexFactoryInput Input, half3x3 TangentToLocal)
{
	half3x3 TangentToWorld = CalcTangentToWorldNoScale(TangentToLocal);

	return TangentToWorld;
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates;

	Intermediates.TangentToLocal = CalcTangentToLocal(Input);
	Intermediates.TangentToWorld = CalcTangentToWorld(Input,Intermediates.TangentToLocal);
	Intermediates.TangentToWorldSign = TangentBias(Input.TangentZ.w) * Primitive.LocalToWorldDeterminantSign;

	// Swizzle vertex color.
	Intermediates.Color = Input.Color FCOLOR_COMPONENT_SWIZZLE;
	return Intermediates;
}

/**
* Get the 3x3 tangent basis vectors for this vertex factory
* this vertex factory will calculate the binormal on-the-fly
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
half3x3 VertexFactoryGetTangentToLocal( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates )
{
	return Intermediates.TangentToLocal;
}

// @return translated world position
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return CalcWorldPosition(Input.Position, Input.ClusterWeights, Input.ClusterIndices);
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
	return InWorldPosition;
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

	// Initialize the whole struct to 0
	// Really only the last two components of the packed UVs have the opportunity to be uninitialized
	Interpolants = (FVertexFactoryInterpolantsVSToPS)0;

#if NUM_MATERIAL_TEXCOORDS

	float2 CustomizedUVs[NUM_MATERIAL_TEXCOORDS];
	GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
	
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
	{
		SetUV(Interpolants, CoordinateIndex, CustomizedUVs[CoordinateIndex]);
	}

#elif NUM_MATERIAL_TEXCOORDS_VERTEX == 0 && USE_PARTICLE_SUBUVS
	SetUV(Interpolants, 0, Input.TexCoords[0]);
#endif	// NUM_MATERIAL_TEXCOORDS

#if NEEDS_LIGHTMAP_COORDINATE
	float2 LightMapCoordinate = 0;
	float2 ShadowMapCoordinate = 0;

	LightMapCoordinate = Input.LightMapCoordinate * LightMapCoordinateScaleBias.xy + LightMapCoordinateScaleBias.zw;
	#if STATICLIGHTING_TEXTUREMASK
		ShadowMapCoordinate = Input.LightMapCoordinate * ShadowMapCoordinateScaleBias.xy + ShadowMapCoordinateScaleBias.zw;
	#endif	// STATICLIGHTING_TEXTUREMASK

	SetLightMapCoordinate(Interpolants, LightMapCoordinate, ShadowMapCoordinate);
#endif	// NEEDS_LIGHTMAP_COORDINATE

	SetTangents(Interpolants, Intermediates.TangentToWorld[0], Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
	SetColor(Interpolants, Intermediates.Color);

	return Interpolants;
}

/** for depth-only pass */
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
	return CalcWorldPosition(Input.Position, Input.ClusterWeights, Input.ClusterIndices);
}

// @return previous translated world position
float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return mul(Input.Position, PreviousLocalToWorld);
}

#if USING_TESSELLATION
	struct FVertexFactoryInterpolantsVSToDS
	{
		FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
	};

	float2 VertexFactoryGetTextureCoordinateDS( FVertexFactoryInterpolantsVSToDS Interpolants )
	{
	#if NUM_MATERIAL_TEXCOORDS
		return Interpolants.InterpolantsVSToPS.TexCoords[0].xy;
	#else // #if NUM_MATERIAL_TEXCOORDS
		return float2(0,0);
	#endif // #if NUM_MATERIAL_TEXCOORDS
	}

	FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
	{
		return Input.InterpolantsVSToPS;
	}

	/** Converts from vertex factory specific interpolants to a FMaterialTessellationParameters, which is used by material inputs. */
	FMaterialTessellationParameters GetMaterialTessellationParameters(FVertexFactoryInterpolantsVSToDS Interpolants, float3 CameraLocalWorldPosition)
	{
		FMaterialTessellationParameters	Result;
	#if NUM_MATERIAL_TEXCOORDS
		UNROLL
		for(int CoordinateIndex = 0;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex += 2)
		{
			Result.TexCoords[CoordinateIndex] = Interpolants.InterpolantsVSToPS.TexCoords[CoordinateIndex/2].xy;
			if(CoordinateIndex + 1 < NUM_MATERIAL_TEXCOORDS)
			{
				Result.TexCoords[CoordinateIndex + 1] = Interpolants.InterpolantsVSToPS.TexCoords[CoordinateIndex/2].zw;
			}
		}
	#endif	// NUM_MATERIAL_TEXCOORDS

		half3 TangentToWorld0 = Interpolants.InterpolantsVSToPS.TangentToWorld0.xyz;
		half4 TangentToWorld2 = Interpolants.InterpolantsVSToPS.TangentToWorld2;

	#if INTERPOLATE_VERTEX_COLOR
		Result.VertexColor = Interpolants.InterpolantsVSToPS.Color;
	#endif	// INTERPOLATE_VERTEX_COLOR

		Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );

		Result.TangentToWorldPreScale = 1;

		Result.WorldPosition = CameraLocalWorldPosition + View.ViewOrigin.xyz;

		return Result;
	}

	FVertexFactoryInterpolantsVSToDS VertexFactoryGetInterpolantsVSToDS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
	{
		FVertexFactoryInterpolantsVSToDS Interpolants;
		Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates, VertexParameters);
		return Interpolants;
	}

	FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
	{
		FVertexFactoryInterpolantsVSToDS O;
	
		// Do we really need to interpolate TangentToWorld2 here? It should be replaced by the
		// interpolated normal from 'whatever' interpolation scheme we're using
	
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld0.xyz);
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld2);
	#if INTERPOLATE_VERTEX_COLOR
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.Color);
	#endif

	#if NEEDS_LIGHTMAP_COORDINATE
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LightMapCoordinate);
	#endif

	#if NUM_MATERIAL_TEXCOORDS
		UNROLL
		for(int tc = 0; tc < (NUM_MATERIAL_TEXCOORDS+1)/2; ++tc)
		{
			TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TexCoords[tc]);
		}
	#endif

		return O;
	}

	float3x3 VertexFactoryGetTangentToLocalDS(FVertexFactoryInterpolantsVSToDS Interpolants)
	{
		// This duplicates stuff already going on in GetMaterialTessellationParameters(), so
		// maybe the hull shader could leverage that instead?
		half3 TangentToWorld0 = Interpolants.InterpolantsVSToPS.TangentToWorld0.xyz;
		half4 TangentToWorld2 = Interpolants.InterpolantsVSToPS.TangentToWorld2;
		float3x3 TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );

		return TangentToWorld;
	}
#endif // #if USING_TESSELLATION

